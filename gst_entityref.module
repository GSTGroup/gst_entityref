<?php
/**
* @file
* GST Entity Reference
*
*/

/*
 * GLOBAL DEFINES
 */
//define('GST_FIREPHP_ENABLED', 1);

// define('GST_GROUP_SELECT_TABLE_WIDGET', 'gst_og_group_select_table');

define('GST_QUERY_ARG', 'query');
define('GST_CALLBACK_ARG', 'callback');

/**
* Implements hook_help().
*/
function gst_entityref_help($path, $arg) {
  if ($path == 'admin/help#gst_entityref') {
    return t('GST Entity Reference Module.');
  }   
}

/**
* Implementation of hook_init().
*/
function gst_entityref_init() {
  if (GST_FIREPHP_ENABLED) {
    // FirePHP Library : http://www.firephp.org/HQ/Use.htm
    // Docs: http://docs.sourcemint.org/firephp.org/firephp/1/-docs/API/FirePHP
    $firephp_path = libraries_get_path('FirePHPCore');
    $firephp_path = ($firephp_path ? $firephp_path . '/lib/FirePHPCore/' : '');
    include_once $firephp_path . 'FirePHP.class.php';
    //module_load_include('php', 'devel', "FirePHPCore/lib/FirePHPCore/FirePHP.class");
    //require_once('FirePHPCore/FirePHP.class.php');
    global $firephp;
    $firephp = FirePHP::getInstance(true);
    $options = array('maxObjectDepth' => 7,
                     'maxArrayDepth' => 7,
                     'maxDepth' => 10,
                     'useNativeJsonEncode' => true,
                     'includeLineNumbers' => true);
    $firephp->setOptions($options);  // or FB::setOptions($options);
    //$firephp->setEnabled(false);  // To turn off ALL FirePHP Console Messages
  
    //$mail_system = variable_get('mail_system');
    //dpm($mail_system);
    //dfb($mail_system, "mail_system");
  }
}


/**
 * Implements hook_menu().
 */
function gst_entityref_menu() {
  $items = array();

  $items['gst_entityref/search_jsonp/%/%/%/%/%/%'] = array(
    'title' => 'GST Entity Reference Autocomplete',
    'page callback' => 'gst_entityref_autocomplete_callback',
    'page arguments' => array(2, 3, 4, 5, 6, 7),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  
  $items['gst_entityref/search_jsonp/%/%/%/%/%'] = array(
      'title' => 'GST Entity Reference Autocomplete',
      'page callback' => 'gst_entityref_autocomplete_callback',
      'page arguments' => array(2, 3, 4, 5, 6),
      'access callback' => TRUE,
      'type' => MENU_CALLBACK,
  );

  $items['gst_entityref/search_jsonp/%/%/%/%'] = array(
        'title' => 'GST Entity Reference Autocomplete',
        'page callback' => 'gst_entityref_autocomplete_callback',
        'page arguments' => array(2, 3, 4, 5),
        'access callback' => TRUE,
        'type' => MENU_CALLBACK,
  );
  
  return $items;
}

/**
* Implements hook_theme().
*/
function gst_entityref_theme() {
   return array(
     'gst_entityref' => array(
     	//'variables' => array('element' => NULL),
   		'render element' => 'element',
     ),
     'gst_entityref_result' => array(
       'variables' => array('result' => NULL, 'instance' => NULL),       
     ),     
   );
}

/**
* Theme an individual GST Entity Ref Widget
*/
function theme_gst_entityref($variables) {
  global $base_root, $base_path;
  $element = $variables['element'];
  $attributes = &$variables['element']['#attributes'];
  $gst_entityref_options = $element['#gst_entityref_options'];
  $textfield_name = $gst_entityref_options['textfield_name'];
    
  // Set unique id
  if (!isset($attributes['id'])) {
    $attributes['id'] = _gst_entityref_get_id();
  }
  $source = $base_root . $base_path . 'gst_entityref/search_jsonp' . 
  	'/' . $gst_entityref_options['widget_type'] .                                      
  	'/' . $gst_entityref_options['field_name'] . 
  	'/' . $gst_entityref_options['entity_type'] . 
  	'/' . $gst_entityref_options['bundle_name'] . 
    //'/{query}/{callback}';
  	'?' . GST_QUERY_ARG . '={query}';
  if ($gst_entityref_options['jsonp']) {
    $source .= '&' . GST_CALLBACK_ARG . '={callback}';
  }
  
  // Fill GST EntityRef Options / Settings  
  $gst_entityref_options += array(
    'id' => $attributes['id'],
    'input_id' => $element[$textfield_name]['#id'],
    'source' => $source,
    //'alwaysShowList' => TRUE,      // For Testing - set to FALSE for Production
  );
  
  // Add gst_entityref.js file to include Behaviors
  $js_path = drupal_get_path('module', 'gst_entityref') . '/gst_entityref.js';
  drupal_add_js($js_path);
  
  // Set Drupal.Settings DOM Object
  drupal_add_js(array('gst_entityref' => array('#'. $attributes['id'] => $gst_entityref_options)), 'setting');
  
  // Load YUI Base Javascript (all other files will be lazy-loaded with YUI.use() )
  //drupal_add_js('http://yui.yahooapis.com/3.4.1/build/yui/yui-min.js', 'external');
  drupal_add_js('http://yui.yahooapis.com/3.4.1/build/yui/yui.js', 'external');
  
  // Begin Building Output
  $output = '<div' . drupal_attributes($attributes) . ">\n";  
  $output .= drupal_render($element[$textfield_name]);
  $output .= '</div>';
  
  return $output;
}

function theme_gst_entityref_result($vars) {
  global $base_root, $base_path;
  $result = $vars['result'];
  $entity = $vars['entity'];
  $instance = $vars['instance'];
  $field = $vars['field'];
  $field_type = $field['type'];  
  $tokenReplacement = $instance['widget']['settings']['tokenReplacement'];
  $output = '';
  $format = gst_entityref_get_resultFormatTemplate($instance);
  
  // Create $tokens/$values arrays
  $tokens = array();
  $values = array();
  foreach($result as $k => $v) {
    if (is_object($v) || is_array($v)) {
      continue;
    }
    $fkey = '{'.$k.'}';
    $tokens[] = $fkey;
    $values[] = '<span>'.$v.'</span>';
  }
  
  // Now perform replacement
  switch ($tokenReplacement) {
    case 'SERVER':
      // token [] replacement
      switch ($field_type) {
        case 'entityreference':
          $target_type = $field['settings']['target_type'];  // eg. field_collection_item          
          $output = token_replace($format,
            array($target_type => $entity), array('sanitize' => FALSE, 'clear' => TRUE));          
          break;
        case 'node_reference':          
          $output = token_replace($format,
            array('node' => $entity), array('sanitize' => FALSE, 'clear' => TRUE));          
          break;
        case 'user_reference':
          $output = token_replace($format,
            array('user' => $entity), array('sanitize' => FALSE, 'clear' => TRUE));
          break;
      }
      // token {} replacement
      $output = str_replace($tokens, $values, $output);
      break;
      
    case 'CLIENT':
      // Format $values so it is of the format {key} = value (instead of key = value)
      $output = str_replace($tokens, $values, $format);      
      break;
  }
  
  return $output;  
}

/**
 * 
 * Implements hook_tokens_alter()
 * @param array $replacements
 * @param array $context
 */
function gst_entityref_token_info_alter(array &$data) {
  
  $data['tokens']['field_collection_item']['host-entity'] = array(
    'name' => 'Host Entity',
    'type' => 'node',
    'entity-token' => TRUE,
    'description' => t('The hosting Entity of the field_collection_item'),
  );
  $data['tokens']['field_collection_item']['host-entity-id'] = array(
      'name' => 'Host Entity ID',
      'type' => 'integer',
      'entity-token' => TRUE,
      'description' => t('The hosting Entity ID of the field_collection_item'),
  );
  $data['tokens']['field_collection_item']['host-entity-type'] = array(
      'name' => 'Host Entity Type',
      'type' => 'string',
      'entity-token' => TRUE,
      'description' => t('The hosting Entity Type of the field_collection_item'),
  );    
}


function gst_entityref_tokens($type, $tokens, array $data = array(), array $options = array()) {
  return;  
  if ($type == 'entity' && $data['entity_type'] == 'field_collection_item' && !empty($data['entity'])) {
    // ADFDONE: Add the ->host_entity properties here
    // I do this in the hook_entity_load() below. Much easier.
    $entity = $data['entity'];    
  }
}

function gst_entityref_entity_load(array $entities, $type) {
  if ($type == 'field_collection_item' && isset($entities)) {
    foreach ($entities as $entity) {
      $entity->host_entity = $entity->hostEntity();
      $entity->host_entity_id = $entity->hostEntityId();
      $entity->host_entity_type = $entity->hostEntityType();
    }
  }
}
/*
 * FIELD
 */




/*
 * WIDGET
 */


/**
* Implements hook_field_widget_info().
*/
function gst_entityref_field_widget_info() {
  $widgets['gst_entityref_autocomplete'] = array(
    'label' => t('GST Autocomplete'),
    'description' => t('An enhanced multi-column autocomplete text field.'),
    'field types' => array('entityreference', 'node_reference', 'user_reference'),
    'settings' => array(
      'match_operator' => 'CONTAINS',
      'size' => 60,
      // We don't have a default here, because it's not the same between
      // the two widgets, and the Field API doesn't update default
      // settings when the widget changes.
  		'path' => '',
  		'use_jsonp' => TRUE,
  		'resultFormatterType' => 'TABLE',
  		'resultFormatterCustom' => '',
  		'resultFormatterFile' => '',
  		'maxResults' => 20,
  		'minQueryLength' => 2,
  		'queryDelay' => 100,
  		'subFilter' => TRUE,
  		'subFilterDelimiter' => ',',
  		'inputResultText' => '',
  		'tokenReplacement' => 'SERVER',  		  		
    ),
  );
/*
  $widgets['gst_entityref_nr_autocomplete'] = array(
    'label' => t('GST Reference Autocomplete'),
    'description' => t('An enhanced multi-column autocomplete text field.'),
    'field types' => array('node_reference'),
    'settings' => array(
      'match_operator' => 'CONTAINS',
      'size' => 60,
      // We don't have a default here, because it's not the same between
      // the two widgets, and the Field API doesn't update default
      // settings when the widget changes.
    	'path' => '',
    	'use_jsonp' => TRUE,
  		'resultFormatterType' => 'TABLE',
    	'resultFormatterCustom' => '',
  		'resultFormatterFile' => '',
  		'maxResults' => 20,
  		'minQueryLength' => 2,
  		'queryDelay' => 100,
  		'subFilter' => TRUE,
  		'subFilterDelimiter' => ',',
  		'inputResultText' => '',
  		'tokenReplacement' => 'SERVER',  		
    ),
  );
  */
  
  return $widgets;
}


/**
 * Implements hook_field_widget_settings_form().
 */
function gst_entityref_field_widget_settings_form($field, $instance) {
  $widget = $instance['widget'];
  $settings = $widget['settings'] + field_info_widget_settings($widget['type']);

  $form = array();
  $field_type = $field['type']; // entityreference | node_reference | user_reference
  if ($widget['type'] == 'gst_entityref_autocomplete') {
    $form['use_jsonp'] = array(
    	'#type' => 'checkbox',
      '#title' => t('Use JSONP Request/Callback'),
      '#default_value' => isset($settings['use_jsonp']) ? 
        $settings['use_jsonp'] : TRUE,
     	'#access' => TRUE,
    );

    $form['resultFormatterType'] = array(
      '#type' => 'select',
      '#title' => t('Result formatter type'),
      '#default_value' => isset($settings['resultFormatterType']) ? $settings['resultFormatterType'] : 'TABLE',
      '#options' => array(
        'TABLE' => t('Table'),
    		'FILE' => t('Template File'),
        'CUSTOM' => t('Custom'),
        ),
    	'#required' => TRUE,
      '#description' => t('Select the method used to display results.'),
    );

    $form['resultFormatterFile'] = array(
        '#type' => 'textfield',
        '#title' => t('Custom result formatter template file'),
        '#default_value' => isset($settings['resultFormatterFile']) ? $settings['resultFormatterFile'] : '',
      	'#required' => FALSE,      	
        '#description' => t('Enter the custom result formatter template file to use.</br>' .
          'To indicate a relative file to a module or theme, format file as module-name:relative/path/'),
        '#states' => array(
          'visible' => array(  // action to take.
          ':input[name="instance[widget][settings][resultFormatterType]"]' => array('value' => 'FILE'),
        ),
      ),
    );
    
    $form['resultFormatterCustom'] = array(
      '#type' => 'textarea',
      '#title' => t('Custom result formatter template'),
      '#default_value' => isset($settings['resultFormatterCustom']) ? $settings['resultFormatterCustom'] : '',
    	'#required' => FALSE,
    	'#rows' => 7,
      '#description' => t('Enter the custom result formatter template to use.<br>'.
        'You can use any field-alias you specify in the format {alias-name}.<br>'.
        'If tokenReplacement is SERVER you can also use any token field as indicated below.'),
      '#states' => array(
        'visible' => array(  // action to take.
        ':input[name="instance[widget][settings][resultFormatterType]"]' => array('value' => 'CUSTOM'),
        ),
      ),      
    );

    $form['tokenReplacement'] = array(
      '#type' => 'select',
      '#title' => t('Token replacement'),
      '#default_value' => isset($settings['tokenReplacement']) ? $settings['tokenReplacement'] : 'SERVER',
      '#options' => array(
        'CLIENT' => t('Client ({field} tokens only)'),
    		'SERVER' => t('Server ({field} and [node:field] tokens allowed)'),
      ),
    	'#required' => TRUE,
      '#description' => t('Select the method used to provide token replacement in Custom and File formatter templates.'),
    );
    
    $form['maxResults'] = array(
      '#type' => 'textfield',
      '#title' => t('Maximun number of results'),
      '#default_value' => isset($settings['maxResults']) ? $settings['maxResults'] : 20,
      '#element_validate' => array('_element_validate_integer_positive'),
      '#required' => TRUE,
      '#description' => t('Maximum number of results to display. A value of 0 or less will allow an unlimited number of results.'),
    );

    $form['minQueryLength'] = array(
      '#type' => 'textfield',
      '#title' => t('Minimum query length'),
      '#default_value' => isset($settings['minQueryLength']) ? $settings['minQueryLength'] : 2,
      '#element_validate' => array('_element_validate_integer_positive'),
      '#required' => TRUE,
    	'#description' => t('Minimum number of characters that must be entered before a query event will be fired. A value of 0 allows empty queries.'),
    );
    
    $form['queryDelay'] = array(
      '#type' => 'textfield',
      '#title' => t('Query delay (ms)'),
      '#default_value' => isset($settings['queryDelay']) ? $settings['queryDelay'] : 2,
      '#element_validate' => array('_element_validate_integer_positive'),
      '#required' => TRUE,
    	'#description' => t('Number of milliseconds to wait after user input before triggering a query event. If new input occurs before this delay is over, the previous input event will be ignored and a new delay will begin.'),
    );
    
    $form['match_operator'] = array(
      '#type' => 'select',
      '#title' => t('Autocomplete matching'),
      '#default_value' => isset($settings['match_operator']) ? $settings['match_operator'] : 'CONTAINS',
      '#options' => array(
        'STARTS_WITH' => t('Starts with'),
        'CONTAINS' => t('Contains'),
      ),
      '#description' => t('Select the method used to collect autocomplete suggestions. Note that <em>Contains</em> can cause performance issues on sites with thousands of nodes.'),
    );
    $form['size'] = array(
      '#type' => 'textfield',
      '#title' => t('Size of textfield'),
      '#default_value' => isset($settings['size']) ? $settings['size'] : 60,
      '#element_validate' => array('_element_validate_integer_positive'),
      '#required' => TRUE,
    );
    
    $form['inputResultText'] = array(
    	'#type' => 'textfield',
      '#title' => t('Input field result text'),
      '#default_value' => isset($settings['inputResultText']) ? $settings['inputResultText'] : '',
      '#description' => t('This is the text that will be put into the input field once a selection is made.<br>Tokens are allowed.'),      
      '#required' => FALSE,
    );
    
    if (module_exists('token')) {
      // set $token_types depending on $field_type
      switch ($field_type) {
        case 'entityreference':
          $token_types = array(
            //ADFTODO: Do I need to include $instance['entity_type'] here?
            //$instance['entity_type'],      // This will be 'node' - I don't think it applies
            $field['settings']['target_type'],
          );          
          break;
        //ADFHI: Add support for user_reference field type
        case 'node_reference':
          $token_types = array(
            $instance['entity_type']
          );          
          break;
      }
      // Add token module replacements fields      
      $form['tokens'] = array(
        '#type' => 'fieldset',
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
        '#title' => t('Placeholder tokens'),
        '#description' => t("The following placeholder tokens can be used in Input Result Text. When used, they will be replaced with the appropriate values."),
      );
      $token_type = array(
        'theme' => 'token_tree',
        'token_types' => $token_types,
        'global_types' => TRUE,
        'click_insert' => TRUE,
        'recursion_limit' => 2,
      );
      $form['tokens']['help'] = array(
        '#type' => 'markup',
        '#markup' => theme('token_tree', $token_type),
      );    
    }    
  }

  // HOOK_gst_entityref_settings_form_alter
  $vars = array(
    'field' => $field,
    'instance' => $instance,
    'settings' => $settings,
  );
  drupal_alter('gst_entityref_settings_form', $form, $vars);
  return $form;
}

/**
* Implements hook_field_widget_info_alter().
*/
function gst_entityref_field_widget_info_alter(&$info) {
  $info['options_select']['field types'][] = 'entityreference';
  $info['options_buttons']['field types'][] = 'entityreference';
}

/**
* Implements hook_field_widget_form().
*/
function gst_entityref_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  // Return the Standard Entity Reference Form for Testing
  //return _entityreference_field_widget_form($form, $form_state, $field, $instance, $langcode, $items, $delta, $element);
  //ADFHI: Add code that takes the values stored in the $settings and set the YUI to be set correct (including maxQueryLength, etc)
  //ADFHI: Fix term matches. Currently, if you type in "paul" that matches a term, so returns 2 entries, but
  //  since the "highlight" match doesn't match an entry, the drop-down does not show up. Need to fix this.
  // Allow any client form to update widget
  $context = array('field' => $field, 'form' => $form, 'form_state' => $form_state);
  drupal_alter('gst_entityref_instance', $instance, $context);
  $field_type = $field['type'];
  $tokenReplacement = $instance['widget']['settings']['tokenReplacement'];
  switch ($field_type) {
    case 'entityreference':
      $textfield_name = 'target_id';
      switch ($tokenReplacement) {
        case 'SERVER':
          $resultFormatter = 'gst_entityref_server_formatter';
          break;
        case 'CLIENT':
          $resultFormatter = 'gst_entityref_token_formatter';
          break;
      }      
      break;
      
    case 'node_reference':
      $textfield_name = 'nid';
      $resultFormatter = 'gst_entityref_server_formatter';
      break;
      
    case 'user_reference':
        $textfield_name = 'uid';
        $resultFormatter = 'gst_entityref_server_formatter';
        break;      
  }
  switch ($instance['widget']['type']) {
    case 'gst_entityref_autocomplete':
      // We let the Field API handles multiple values for us, only take
      // care of the one matching our delta.      
      if (isset($items[$delta])) {
        $items = array($items[$delta]);
        switch ($field_type) {
          case 'entityreference':
            $entity_id = $items[$delta]['target_id'];
            $entities = entity_load($field['settings']['target_type'], array($entity_id));
            $entity = $entities[$entity_id];            
            break;
          case 'node_reference':
            $entity_id = $items[$delta]['nid'];
            $entity = node_load($entity_id);
            break;           
          case 'user_reference':
              $entity_id = $items[$delta]['uid'];
              $entity = user_load($entity_id);
              break;            
        }
        
        // Load the value for Input field to display
        $inputResultText = gst_entityref_get_inputResultText($entity, $instance);        
      }
      else {
        $items = array();
        $inputResultText = '';
      }
      
      $settings = $instance['widget']['settings'];
      $jsonp = $settings['use_jsonp'];
      $gst_entityref_options = array(
        'widget_type' => 'yui-std',
        //ADFTODO: Add support for StartsWith filtering - currently only support Contains/PhraseMatch
        'resultFilters' => array('gst_entityref_filter_phraseMatch'),
        'field_name' => $field['field_name'],
        'entity_type' => $instance['entity_type'],
        'bundle_name' => $instance['bundle'],
        'jsonp' => $jsonp,
        'maxResults' => $settings['maxResults'],
        'minQueryLength' => $settings['minQueryLength'],
        'queryDelay' => $settings['queryDelay'],
        'resultTextLocator' => 'inputResultText',
        'resultFormatTemplate' => gst_entityref_get_resultFormatTemplate($instance),
        'resultFormatter' => $resultFormatter,
        'subFilter' => $instance['widget']['settings']['subFilter'],
      	'subFilterDelimiter' => $instance['widget']['settings']['subFilterDelimiter'],
      	'textfield_name' => $textfield_name,
      	'tokenReplacement' => $tokenReplacement,
      );
      $element_ref = array(
      	'#type' => 'gst_entityref',
      	'#theme' => 'gst_entityref',
        '#tree' => TRUE,
      	'#title' => $instance['label'],
        '#default_value' => '',        
        '#attributes'=> array(
          'class' => array('gst-entityref'),
          ),
        '#gst_entityref_options' => $gst_entityref_options,
        '#widget' => $instance['widget'],
      );      
      $element_ref[$textfield_name] = array(
        '#type' => 'textfield',
        '#title' => $instance['label'],
      	'#default_value' => $inputResultText,
        '#attributes' => array(
        ),
      	'#element_validate' => array('_gst_entityref_autocomplete_validate'),
      );
      
      break;
  }
  
  
  return $element_ref;
}

function _gst_entityref_autocomplete_validate($element, &$form_state, $form) {
  // If a value was entered into the autocomplete...
  $value = '';
  if (!empty($element['#value'])) {
    // Take "label (entity id)', match the id from parenthesis.
    if (preg_match("/.+\((\d+)\)/", $element['#value'], $matches)) {
      $value = $matches[1];
    }
  }

  // Update the value of this element so the field can validate the product IDs.
  form_set_value($element, $value, $form_state);
}


/*
 * Adds a field to be used for searching/display/highlight
 * This function should ONLY be called from teh hook_gst_entityref_settings_form_alter hook
 * 
 * @param $form The form to add the joins to. This is passed in the HOOK
 * @param $data This is an array of data containing the Join to add The array
 *   should be of the form:
 *   array(
 *   	'unique-name' => array(
 *   		'join' => array(),
 *   		''
 *   	),
 *   )
 * @return
 */
function gst_entityref_add_filter_field(array &$form, array $data) {
  if (!isset($form['filter_fields'])) {
    $form['filter_fields'] = array();
  }  
  $form['filter_fields'] += $data;
}

function _get_user_reference_matches_standard($field, $instance, $options) {
  // Avoid useless work.
  $filter_roles = array_filter($field['settings']['referenceable_roles']);
  $filter_status = array_filter($field['settings']['referenceable_status']);
  if (!count($filter_status) && !count($filter_roles)) {
    return array();
  }
  
  $query = db_select('users', 'u')
  ->addMetaData('id', ' _user_reference_potential_references_standard');
  $user_uid_alias   = $query->addField('u', 'uid');
  $user_name_alias = $query->addField('u', 'name', 'user_name');
  $node_email_alias  = $query->addField('u', 'mail',  'user_email');  
  $query->addTag('gst_entityref');   // Hook = gst_entityref_query_gst_entityref_alter()
  $query->addMetaData('widget', $instance['widget']);
  $query->addMetaData('settings', array(
      'match' => $options['query_arg'],
  ));  
  
  
  // Enable this filter only if any statuses checked (and not both).
  if (count($filter_status) == 1) {
    $query->condition('u.status', array_keys($filter_status), 'IN');
  }
  
  // Skip filter when "authenticated user" choosen.
  if ($filter_roles && !isset($filter_roles[DRUPAL_AUTHENTICATED_RID])) {
    $query->join('users_roles', 'r', 'u.uid = r.uid');
    $query->condition('r.rid', array_keys($filter_roles), 'IN');
  }

  /*
  if ($options['query_arg'] !== '') {
    switch ($options['match']) {
      case 'CONTAINS':
        $query->condition('u.name', '%' . $options['query_arg'] . '%', 'LIKE');
        break;
  
      case 'STARTS_WITH':
        $query->condition('u.name', $options['query_arg'] . '%', 'LIKE');
        break;
  
      case 'EQUALS':
      default: // no match type or incorrect match type: use "="
        $query->condition('u.name', $options['query_arg'], '=');
        break;
    }
  }
  */
  
  if ($options['ids']) {
    $query->condition('u.uid', $options['ids'], 'IN');
  }
  
  // Explicitly exclude the anonymous user.
  $query->condition('u.uid', 0, '<>');
  
//   if ($options['limit']) {
//     $query->range(0, $options['limit']);
//   }
  $query->orderBy('u.name');
  
  $results = $query->execute()->fetchAll();  
  $matches = _flatten_matches($field, $instance, $results);
  return $matches;   
}


function _get_user_reference_matches($field, $instance, $options) {
  // Fill in default options.
  $options += array(
    'query_arg' => '',
    'callback' => '',
  );

  $matches = FALSE;
  //ADFTODO: Finish adding "views" support. In order to add this, I will need
  // to do something similar to what is done in references.module
  // Specifically, look at the references_handler_argument.inc file - that is where the "args" get processd.
  // Views support will not be "easy" to add...it will be a bit complicated.
  if (module_exists('views') && !empty($field['settings']['view']['view_name'])) {
    $matches = _get_node_reference_matches_views($field, $instance, $options);
  }

  if ($matches === FALSE) {
    $matches = _get_user_reference_matches_standard($field, $instance, $options);
  }

  return $matches;
}


function _get_node_reference_matches_standard($field, $instance, $options) {
  // Avoid useless work
  if (!count($field['settings']['referenceable_types'])) {
    return array();
  }
  
  $query = db_select('node', 'n');
  $node_nid_alias   = $query->addField('n', 'nid');
  $node_title_alias = $query->addField('n', 'title', 'node_title');
  $node_type_alias  = $query->addField('n', 'type',  'node_type');
  $query->addTag('node_access');
  $query->addTag('gst_entityref');   // Hook = gst_entityref_query_gst_entityref_alter()
  $query->addMetaData('widget', $instance['widget']);
  $query->addMetaData('settings', array(
    'match' => $options['query_arg'],
    ));
  $query->addMetaData('id', ' _node_reference_potential_references_standard');
  
  if (is_array($field['settings']['referenceable_types'])) {
    $query->condition('n.type', $field['settings']['referenceable_types'], 'IN');
  }
  
  //ADFTODO: I handle this in the query_extra - if I put it HERE then it wrecks the OR
  // query - not sure the best approach, but for now that is how I have written it.
  // That means there MUST be at least ONE condition specified in the instance_alter/query_extra or
  // the widget will NOT work
  //ADFTODO: Perhaps a solution would be to add these conditions to the query_extra?
  // query_extra is stored in $instance['widget']['settings']['query_extra'] so I could store then
  // and then read, then add to them in the instance_alter...
  $query_extra = array(
    'joins' => array(),
    'fields' => array(),
    'conditions' => NULL,
  );
  $instance['widget']['settings']['query_extra'] &= $query_extra;
  /*  
  if ($options['query_arg'] !== '') {
    switch ($options['match']) {
      case 'CONTAINS':
        $query->condition('n.title', '%' . $options['query_arg'] . '%', 'LIKE');
        break;
  
      case 'STARTS_WITH':
        $query->condition('n.title', $options['query_arg'] . '%', 'LIKE');
        break;
  
      case 'equals':
      default: // no match type or incorrect match type: use "="
        $query->condition('n.title', $options['query_arg']);
        break;
    }
  }
	*/
//ADFTODO: Figure out if I need this at all.
//   if ($options['ids']) {
//     $query->condition('n.nid', $options['ids'], 'IN');
//   }

//ADFHI: add limit support  
//   if ($options['limit']) {
//     $query->range(0, $options['limit']);
//   }
  
  $query
  ->orderBy($node_title_alias)
  ->orderBy($node_type_alias);
  $qs = $query->__toString();
  $results = $query->execute()->fetchAll();
  $matches = _flatten_matches($field, $instance, $results);
  return $matches;
  $imatches = array();
  $matches = array();
  // Load Nodes
  $nids = array();
  foreach ($results as $node) {
    $nids[] = $node->nid;
  }
  $nodes = node_load_multiple($nids);
  foreach ($results as $row) {
    $entity_id = $row->nid;
    $node = $nodes[$entity_id];
    $imatches[$entity_id] = (array) $row;
    //$imatches[$entity_id]['#entity'] = (array) $node;
    $inputResultText = gst_entityref_get_inputResultText($node, $instance);
    $imatches[$entity_id]['inputResultText'] = $inputResultText;
    $vars = array(
      'result' => $node,
      'entity' => $node,
      'field' => $field,
      'instance' => $instance,      
    );
    $imatches[$entity_id]['#formattedResult'] = theme('gst_entityref_result', $vars);

    $matches[] = _mark_nonvalues($imatches[$entity_id], array('nid', 'node_type')); 
  }
  return $matches;  
}

function _gst_node_reference_matches_views($field, $instance, $options) {
  $entity_type = 'node';
  $settings = $field['settings']['view'];
  $view_name = $settings['view_name'];
  $view_display = $settings['display_name'];
  $view_args = $settings['args'];

  $entity_info = entity_get_info($entity_type);
  
  // Check that the view is valid and the display still exists.
  $view = views_get_view($view_name);
  if (!$view || $view->base_table != $entity_info['base table'] || !isset($view->display[$display_name])) {
    return FALSE;
  }
  
  // Temporary backwards compatibility for fields migrated from CCK D6: accept
  // 'default' display, but dynamically add a 'references' display out of it.
  if ($display_name == 'default') {
    $display_name = $view->add_display('references');
  }
  
  $view->set_display($display_name);
  
  
}

function _get_node_reference_matches($field, $instance, $options) {
  // Fill in default options.
  $options += array(
    'query_arg' => '',
    'callback' => '',
  );

  $matches = FALSE;
  //ADFTODO: Finish adding "views" support. In order to add this, I will need
  // to do something similar to what is done in references.module
  // Specifically, look at the references_handler_argument.inc file - that is where the "args" get processd.
  // Views support will not be "easy" to add...it will be a bit complicated.
  if (module_exists('views') && !empty($field['settings']['view']['view_name'])) {    
    $matches = _get_node_reference_matches_views($field, $instance, $options);
  }
  
  if ($matches === FALSE) {
    $matches = _get_node_reference_matches_standard($field, $instance, $options);
  }
  
  return $matches;  
}

// Processes the results of multiple matches and flattens them into 1 row with delimited results (useful for taxonomy terms)
function _flatten_matches($field, $instance, $full_results = array()) {
  $field_type = $field['type'];
  $imatches = array();
  switch ($field_type) {
    case 'entityreference':
      $entity_id_name = 'entity_id';
      break;
    case 'node_reference':
      $entity_id_name = 'nid';
      break;
    case 'user_reference':
      $entity_id_name = 'uid';
      break;
  }
  foreach($full_results as $record) {
    $rec = (array)$record; // Convert stdClass to Array (so we can merge)
    $entity_id = $rec[$entity_id_name];
    if (isset($imatches[$entity_id])) {
      $imatches[$entity_id]['#multiple'] = isset($imatches[$entity_id]['#multiple']) ? $imatches[$entity_id]['#multiple']+1 : 2;
      // Create "multiple" entries for each entry
      foreach($rec as $k => $v) {
        if ($k[0] === '#' || !isset($v)) {
          continue;
        }
        if (is_array($imatches[$entity_id][$k])) {
          // This Key is a Multi-Value - add NEW value (if it is the same as an existing, it will do NOTHING, since array is associative)
          $imatches[$entity_id][$k][$v] = $v;
        } elseif (isset($rec[$k]) && $imatches[$entity_id][$k] != $rec[$k]) {
          // New Value Exists (not NULL), not the same as Existing - need to convert to an array to store both.
          $existing = $imatches[$entity_id][$k];
          $imatches[$entity_id][$k] = array(
            $existing => $existing,
          $v => $v,
          );
        } else {
          // Not an array, but New value either doesn't exist, or is same as existing - do nothing
        }
      }
    } else {
      $imatches[$entity_id] = $rec;
    }
  }

  $mk_prefix = 'm_';
  $sk_prefix = 's_';  
  switch ($field_type) {
    case 'entityreference':
      // Load the Entity objects for Token Processing
      $target_entity_type = $field['settings']['target_type'];
      $entities = entity_load($target_entity_type, array_keys($imatches));
      $nonvalues = array('entity_id', 'bundle', 'revision_id', 'entity_type');      
      break;
    case 'node_reference':
      $entities = node_load_multiple(array_keys($imatches));      
      $nonvalues = array('nid', 'node_type');
      break;
    case 'user_reference':
      $entities = user_load_multiple(array_keys($imatches));
      $nonvalues = array('uid', 'data', 'created', 'access', 'login');
      break;
  }
  
  // Now fix all the multi-values (convert to delimited strings)
  $inputResultTextTemplate = $instance['widget']['settings']['inputResultText'];
  foreach ($imatches as $entity_id => $rec) {
    if (isset($rec['#multiple']) && $rec['#multiple']) {
      // Handle matches that had multiple matches with the same item_collection entity_id
      // (this likely means the FC has multiple "term" matches)
      foreach ($rec as $k => $v) {
        if (is_array($v)) {
          $mk = $mk_prefix . $k;
          $sk = $sk_prefix . $k;
          $imatches[$entity_id][$sk] = reset($v);          // Store the FIRST value in the s_{key} field
          $imatches[$entity_id][$k] = implode(',', $v);    // Store the delimited value in the {key} field
          // Try and see if the $match passed matches any of these values, if so, set that one, if not, set the FIRST value
        }
      }
    }
    // Add the inputText value to the $match entry
    $inputResultText = gst_entityref_get_inputResultText($entities[$entity_id], $instance);
    $imatches[$entity_id]['inputResultText'] = $inputResultText;
  
    $vars = array(
            'result' => $imatches[$entity_id],
    				'entity' => $entities[$entity_id],            
            'field' => $field,
            'instance' => $instance,               
    );
    $imatches[$entity_id]['#formattedResult'] = theme('gst_entityref_result', $vars);  
  
    // Now create the un-indexed version to send to the CLIENT in JSON
    $matches[] = _mark_nonvalues($imatches[$entity_id], $nonvalues);
  }
  
  return $matches;
}

/**
* Menu callback: autocomplete the label of an entity.
* NOTE: We use query= and callback= URL Args *instead* of standard Drupal /%/% args for
* 		query & callback to solve issues with '/' chars. When I used std %/% the '/' chars
* 		while "converted" correctly on the client, created 403 errors on the server, so I changed code.
*/
function gst_entityref_autocomplete_callback($type, $field_name, $entity_type, $bundle_name) {
  $query_arg = $_GET[GST_QUERY_ARG];
  $callback = $_GET[GST_CALLBACK_ARG];     
  $field = field_info_field($field_name);
  $field_type = $field['type']; // entityreference | node_reference | user_reference
  $instance = field_info_instance($entity_type, $field_name, $bundle_name);
  // Allow any client form to update widget
  $context = array('field' => $field, 'form' => Null, 'form_state' => Null);
  drupal_alter('gst_entityref_instance', $instance, $context);  
  
  $options = array(
    'query_arg' => $query_arg,
    'callback' => $callback,
    'match' => $instance['widget']['settings']['match_operator'],
  );
  switch ($field_type) {
    case 'node_reference':
      $matches = _get_node_reference_matches($field, $instance, $options);
      _drupal_jsonp_output($matches, $callback);
      break;

    case 'user_reference':
      $matches = _get_user_reference_matches($field, $instance, $options);
      _drupal_jsonp_output($matches, $callback);
      break;
      
    case 'entityreference':    
      $matches = array();      // Un-Indexed list of Matches (this is what we MUST return to JSONP)
      $imatches = array();     // Indexed list of Matches (indexed by entity_id)
      if (!$field || !$instance || $field['type'] != 'entityreference' || !field_access('edit', $field, $entity_type)) {
        return MENU_ACCESS_DENIED;
      }
    
      $handler = entityreference_get_handler($field);
      
      $field['entity_type'] = $entity_type;
      $field['bundle_name'] = $bundle_name;
      $efq = _buildEntityFieldQuery($field, $query_arg, $instance['widget']['settings']['match_operator'], 20);
      $efq->addMetaData('widget', $instance['widget']);
      //NOTE: The following is "hackish" but is *necessary* because of how the EFQ handles
      // query results. Problem is, the EFQ HURLS any fields that are added, and ONLY returns
      // an "entity" records, so it doesn't matter that I just went out to the DB and grabbed
      // a set of 8 tables, all I get back is the ENTITY. While I can understand this, there
      // are *times* when I want what I asked for (ie. the set of field results).
      // Now, I could junk the EFQ entirely, and use a db_select() (which might be better),
      // but I wrote it this way for now. THAT is the reason I run the $efq->execute() and then later
      // run the $select_query->execute().
      $results = $efq->execute();
      $select_query = $efq->metaData['select_query'];
      $full_results = $select_query->execute();
      // Build the $matches result set to send to the client 
      // (NOTE: This result set COULD have MULTIPLE entries for each FC item due to the taxonomy matches - so check for that.
      $mk_prefix = 'm_';
      $sk_prefix = 's_';
      $matches = _flatten_matches($field, $instance, $full_results);
      if (FALSE && !empty($full_results)) {
        foreach($full_results as $record) {
          $rec = (array)$record; // Convert stdClass to Array (so we can merge)
          $entity_id = $rec['entity_id'];
          if (isset($imatches[$entity_id])) {
            $imatches[$entity_id]['#multiple'] = isset($imatches[$entity_id]['#multiple']) ? $imatches[$entity_id]['#multiple']+1 : 2;
            // Create "multiple" entries for each entry
            foreach($rec as $k => $v) {
              if ($k[0] === '#' || !isset($v)) { continue; }
              if (is_array($imatches[$entity_id][$k])) {
                // This Key is a Multi-Value - add NEW value (if it is the same as an existing, it will do NOTHING, since array is associative)            
                $imatches[$entity_id][$k][$v] = $v;
              } elseif (isset($rec[$k]) && $imatches[$entity_id][$k] != $rec[$k]) {
                // New Value Exists (not NULL), not the same as Existing - need to convert to an array to store both.
                $existing = $imatches[$entity_id][$k];
                $imatches[$entity_id][$k] = array(
                  $existing => $existing,
                  $v => $v,
                );
              } else {
                // Not an array, but New value either doesn't exist, or is same as existing - do nothing            
              }
            }
          } else {
            $imatches[$entity_id] = $rec;        
          }
        }
        // Load the Entity objects for Token Processing
        $target_entity_type = $field['settings']['target_type'];
        $entities = entity_load($target_entity_type, array_keys($imatches));
        // Now fix all the multi-values (convert to delimited strings)
        $inputResultTextTemplate = $instance['widget']['settings']['inputResultText'];
        foreach ($imatches as $entity_id => $rec) {
          if (isset($rec['#multiple']) && $rec['#multiple']) {
            // Handle matches that had multiple matches with the same item_collection entity_id
            // (this likely means the FC has multiple "term" matches)
            foreach ($rec as $k => $v) {
              if (is_array($v)) {
                $mk = $mk_prefix . $k;
                $sk = $sk_prefix . $k;
                $imatches[$entity_id][$sk] = reset($v);          // Store the FIRST value in the s_{key} field
                $imatches[$entity_id][$k] = implode(',', $v);    // Store the delimited value in the {key} field
                // Try and see if the $match passed matches any of these values, if so, set that one, if not, set the FIRST value
                //ADFDONE: Add code to do the above (I should do this AFTER I move to array-based $match strings)
                //$imatches[$entity_id][$k] = reset($v); // Store the FIRST value in the non-multiple
              }        
            }
          }
          // Add the inputText value to the $match entry
          //ADFDONE: Figure out why I need to turn sanitize off. If I turn it on, it passes & chars to browser for apostrophes      
    //       $inputResultText = token_replace($inputResultTextTemplate, 
    //         array('field_collection_item' => $entities[$entity_id]), array('sanitize' => FALSE));      
    //       $imatches[$entity_id]['inputResultText'] = $inputResultText . " (" . $entity_id . ")";
          $inputResultText = gst_entityref_get_inputResultText($entities[$entity_id], $instance);
          $imatches[$entity_id]['inputResultText'] = $inputResultText;
          
          $vars = array(
            'result' => $imatches[$entity_id],
            'field' => $field,
            'instance' => $instance,
            'entity' => $entities[$entity_id],      
          );
          $imatches[$entity_id]['#formattedResult'] = theme('gst_entityref_result', $vars);
          
          
          // Now create the un-indexed version to send to the CLIENT in JSON
          $matches[] = _mark_nonvalues($imatches[$entity_id], array('entity_id', 'bundle', 'revision_id', 'entity_type'));      
        }
      }
      
      _drupal_jsonp_output($matches, $callback);
    break;
  }  
}

function _buildEntityFieldQuery($field, $match = NULL, $match_operator, $limit = 0) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', $field['settings']['target_type']);
  if ($field['settings']['handler_settings']['target_bundles']) {
    $query->entityCondition('bundle', $field['settings']['handler_settings']['target_bundles'], 'IN');
  }
  if (isset($match)) {
    $entity_info = entity_get_info($field['settings']['target_type']);
    if (isset($entity_info['entity keys']['label'])) {
      $query->propertyCondition($entity_info['entity keys']['label'], $match, $match_operator);
    }
    //$query->propertyCondition('title', $match, $match_operator);
  }

  // Add a generic entity access tag to the query.
  $query->addTag($field['settings']['target_type'] . '_access');
  //$query->addTag('entityreference'); // Hook = gst_entityref_query_entityreference_alter()


  // --- NOTE ---
  // I can't add the "joins" here and then expect them to be processed
  // The problem is quite simple, if I add the "joins" here (first) then the first
  // time they will EVER be processed will be upon the first AutoComplete AJAX request.
  // By that time, the YUI code has ALREADY been sent to the client.
  // I will need to create the "joins" early (before the Widget is sent to the client)
  // and then later take that set of "joins" and perform the "join" operation.
  // Probably I should create an API that allows the user to "specify" the
  // Joins on "build" and then later, take that set of "joins" and then add them
  // in the gst_entityref_query_gwst_entityref_alter() routine (adding them to the db_select() )
  // --- NOTE ---

  $query->addTag('gst_entityref'); // Hook = gst_entityref_query_gst_entityref_alter()
  $query->addMetaData('field', $field);


  $target_bundles = $field['settings']['handler_settings']['target_bundles'];
  $tb = array();
  foreach(array_keys($target_bundles) as $bundle_name) {
    $f_field = field_info_field($bundle_name);
    $tb[$bundle_name]['field'] = $f_field;
    foreach($f_field['bundles'] as $entity_type => $entities) {
      foreach($entities as $entity_name) {
        $f_instance = field_info_instance($entity_type, $f_field['field_name'], $entity_name);
        $tb[$bundle_name][$entity_type . "." . $entity_name] = $f_instance;
      }
    }
  }

  //---------------------\\

  // I have decided that it is too ambitious to try and create a "dynamic" system
  // that lets me define the "joins" using a single string. I would have to have
  // extensive schema knowledge and understanding that I don't have.
  // A better system would be to have a "routine" that uses a "tag" to fill the
  // EntityRef with the joins. If I strongly specify how the joins are created
  // later I can add a UI to that interface. At some point then beyond that
  // I can add the "token" like linkage. So the dev of this widget wil be 3
  // phased:
  // 1) Code the joins in PHP (but tied to a specific field)
  // 2) Add a UI that can add that data
  // 3) Add the ability to create that information with the Token system.

  //---------------------\\


  //ADFHI: Clean up "settings" - I have them being stored in the $widget and the $query - need to clean it up.
  $settings = array(
    'match' => $match,
    'match_operator' => $match_operator,    
  );
  $query->addMetaData('settings', $settings);

  if ($limit > 0) {
    $query->range(0, $limit);
  }
  return $query;
}

// Change the key's of non-values from "key" to "#key" so they are skipped
function _mark_nonvalues($entity, $nonvalues) {
  $marked_e = $entity;
  foreach($nonvalues as $nv) {
    if (array_key_exists($nv, $marked_e)) {
      $newk = '#' . $nv;
      $marked_e[$newk] = $marked_e[$nv];
      unset($marked_e[$nv]);
    } 
  }
  return $marked_e;
}

function gst_entityref_get_resultFormatTemplate($instance) {
  $resultFormatterType = $instance['widget']['settings']['resultFormatterType'];
  switch ($resultFormatterType) {
    case 'CUSTOM':
      return $instance['widget']['settings']['resultFormatterCustom'];
      break;
    case 'FILE':
      //ADFTODO: Perhaps process the template with vars? For now I just read it in, I could use
      // bgs_helper_render_form_template() as a base and process it? Not sure why, but I could...?
      // use drupal_get_path(type, name) to get module/theme path
      $resultFormatterFile = $instance['widget']['settings']['resultFormatterFile'];
      if (strpos($resultFormatterFile, ':') === FALSE) {
        // Normal absolute Path
        $file = $resultFormatterFile;
      } else {
        // module:relative/path/ PATH
        $parts = explode(':', $resultFormatterFile, 2);
        if ($base_p = drupal_get_path('theme', $parts[0])) {
          $file = $base_p . '/' . $parts[1];
        } elseif ($base_p = drupal_get_path('module', $parts[0])) {
          $file = $base_p . '/' . $parts[1];
        } else {
          $file = '';
        }
      }
      if (is_readable($file)) {
        if ($contents = file_get_contents($file)) {
          return $contents;
        } else {
          return '';
        }
      }
      break;
  }
}

function gst_entityref_get_inputResultText($entity, $instance, $template = NULL, $append_id = TRUE) {
  $field = field_info_field($instance['field_name']);
  $field_type = $field['type'];
  $inputResultTextTemplate = isset($template) ? $template : $instance['widget']['settings']['inputResultText'];
  switch ($field_type) {
    case 'entityreference':
      $target_type = $field['settings']['target_type'];  // eg. field_collection_item      
      $inputResultText = token_replace($inputResultTextTemplate,
        array($target_type => $entity), array('sanitize' => FALSE));
      if ($append_id) {
        $inputResultText .= " (" . $entity->internalIdentifier() . ")";
      }      
      break;
    case 'node_reference':
      $nid = $entity->nid;      
      $inputResultText = token_replace($inputResultTextTemplate,
        array('node' => $entity), array('sanitize' => FALSE));
      if ($append_id) {
        $inputResultText .= " (" . $nid . ")";
      }      
      break;
    case 'user_reference':
      $uid = $entity->uid;
      $inputResultText = token_replace($inputResultTextTemplate,
        array('user' => $entity), array('sanitize' => FALSE));
      if ($append_id) {
        $inputResultText .= " (" . $uid . ")";
      }
      break;      
  }
  return $inputResultText;
}

function gst_entityref_get_label($entity, $instance, $template = NULL) {
  return gst_entityref_get_inputResultText($entity, $instance, $template, FALSE);
  
//   $field = field_info_field($instance['field_name']);
//   $target_type = $field['settings']['target_type']; // eg. field_collection_item
//   if (!$template) {
//     $template = $instance['widget']['settings']['inputResultText'];
//   }
//   $label = token_replace($template,
//     array($target_type => $entity), array('sanitize' => FALSE));  
//   return $label;
}

function gst_entityref_query_gst_entityref_alter(QueryAlterableInterface $query) {
  if (!$query->alterTags['gst_entityref']) {
    return;
  }
  $widget = $query->getMetaData('widget');
  if (!isset($widget)) { return; }
  $settings = $query->getMetaData('settings');
  $match = $settings['match'];
  $query_extra = $widget['settings']['query_extra'];
  
  // Make Adjustments to Query
  //ADFTODO: Add code to handle alias conflicts in joins
  if (isset($query_extra['joins'])) {
    foreach ($query_extra['joins'] as $j) {
      $method = $j['method'];
      $talias = $query->$method($j['table'], $j['alias'], $j['condition'], $j['args']);
    }
  }
  //ADFTODO: Add code to handle alias conflicts in fields
  //ADFDONE: Add code to handle "sort order" - I should probably add this to the fields as an "option" for each field.
  $orders = array();
  if (isset($query_extra['fields'])) {
    foreach ($query_extra['fields'] as $f) {      
      $falias = $query->addField($f['table_alias'], $f['field_name'], $f['field_alias']);
      if (isset($f['sort'])) {
        $sort_dir = isset($f['sort_dir']) ? $f['sort_dir'] : 'ASC';
        //ADFTODO: Add code to handle two fields with 'sort' => SAME value.
        $orders[$f['sort']] = array(
        	'name' => $f['field_alias'],
        	'dir' => $sort_dir
          );
      }
    }
  }
  ksort($orders);    // Sort by KEY
  foreach ($orders as $i => $order) {
    $query->orderBy($order['name'], $order['dir']);      
  }
  
  //ADFTODO: Add code to handle alias conflicts created by joins/fields to fix $conditions
  //ADFDONE: Add $conditions processing. Should be easy since all it does is copy it in.
  //ADFDONE: When adding conditions, have to replace %match with match value, and have to fix operator 'default' values.
  if (isset($query_extra['conditions'])) {
    $subFilter = $widget['settings']['subFilter'];
    $subFilterDelimiter = $widget['settings']['subFilterDelimiter'];
    $conditions = $query_extra['conditions'];
    $match_operator = $widget['settings']['match_operator'];
    if ($subFilter) {
      // Break query into sub-filters on the subFilterDelimiter (usually a comma (,))
      $match_list = explode($subFilterDelimiter, $match);
      $q_conditions = &$query->conditions();
      foreach ($match_list as $i => $submatch) {
        //$c_conditions = clone $conditions->conditions();
        $cref = $conditions->conditions();        
        $c_conditions = unserialize(serialize($cref));      // This deep-copies the $conditions array
        _process_conditions($c_conditions, $submatch, $match_operator, $i > 0);  // Run subMatch on all Matches except FIRST one
        $q_conditions = array_merge($q_conditions, $c_conditions);
      }
    } else {
      // Handle the query as one long string            
      $c_conditions = &$conditions->conditions();
      _process_conditions($c_conditions, $match, $match_operator);
      $q_conditions = &$query->conditions();
      $q_conditions = array_merge($q_conditions, $c_conditions);      
    }
    $query->where('1=1');  // This marks where->changed = TRUE; the changed property is PROTECTED! (so this hack is nec)
  }
  // Save the db_select SelectQuery object - we will need it LATER
  // - this is necessary because the EFQ returns a "partial" entity; it strips out ALL
  // - the extra "fields" that I add, and I WANT those for display.
  $efq = &$query->getMetaData('entity_field_query');
  // node_reference & user_reference don't use entity_field_query so if we don't find one, dont' save it 
  if (isset($efq)) {    
    $efq->metaData['select_query'] = $query;
  }
  
  // Remove the Alter Tag so I don't end up here AGAIN
  $query->alterTags['gst_entityref'] = 0;
  $qs = $query->__toString();
}

// Process subFilter here.
// I think if I just loop thru ALL the $match entries (if $match has a delimter)
// and do the following I can make it work easily.
// 1) add all $conditions for $match[0] (the first "query").
// 2) loop thru $conditions for every other $match and if $value = %match, then
//    add that condition *again* but with the 2nd (and following) $match[1] value.
//    if $value != %match, REMOVE that condition (or don't add it).
//   NOTE: These 2nd and following $condition loops wil need to be added with db_and()

function _process_conditions(&$conditions, $match, $match_operator, $subMatch = FALSE) {
  foreach($conditions as $key => $condition) {    
    if ($key[0] === '#' || empty($condition['operator'])) {
      // #conjunction OR Literal Condition - Skip
    } else {
      if ($condition['field'] instanceof QueryConditionInterface) {
        // Condition is a Structured Condition Object - recursively process
        $cref = &$condition['field']->conditions();
        _process_conditions($cref, $match, $match_operator);
      } else {
        // Process Condition
        $removeCondition = false;
        $value = isset($condition['value']) ? $condition['value'] : '';
        $op = isset($condition['operator']) ? $condition['operator'] : '';

        switch ($op) {
          case '%default':
          case 'default':
            $m_operator = $match_operator;
            break;
          default:
            $m_operator = isset($op) ? $op : (is_array($value) ? 'IN' : '=');
          break;
        }
        
        switch ($value) {
          case '%match':        // Dynamic Condition
            $c_value = $match;
            break;
          default:              // Static Condition
            // Remove all Static Conditions from subMatches
            $c_value = $value;
            $removeCondition = $subMatch; 
            break;
        }
        switch ($m_operator) {
          case 'CONTAINS':
            $c_operator = "LIKE";
            $c_value = '%'.$c_value.'%';
            break;
          case 'STARTS_WITH':
            $c_operator = "LIKE";
            $c_value = $c_value.'%';
            break;
          default:
            $c_operator = $m_operator;
            break;
        }        
        $conditions[$key]['value'] = $c_value;
        $conditions[$key]['operator'] = $c_operator;
        if ($removeCondition) {
          unset($conditions[$key]);
        }
      }
    }
  }
}

/*
* FIELD FORMATTERS
* ---------------------------------------------------------------------------
*/

function gst_entityref_field_formatter_info() {
  return array(
    'gst_entityref_label' => array(
      'label' => t('GST Label'),
      'description' => t('Display the label of the referenced entities using the gst_entityref module.'),
      //ADFTODO: Add user_reference support to gst_entityref
      'field types' => array('entityreference', 'node_reference'),
      'settings' => array(
        'link' => FALSE,
        'template' => '',
      ),
    ),
  );  
}

/**
* Implements hook_field_formatter_settings_form().
*/
function gst_entityref_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];
  
  switch ($display['type']) {
    case 'gst_entityref_label':
      $element['link'] = array(
        '#title' => t('Link label to the referenced entity (GST)'),
        '#type' => 'checkbox',
        '#default_value' => $settings['link'],
      );
      $element['template'] = array(
        '#title' => t('Template string to use to build label.'),
        '#type' => 'textfield',
        '#size' => 60,
        '#maxlength' => 4096,
        '#default_value' => $settings['template'],
        '#description' => t('Enter a tokenized string to use as the label for this entity reference.<br>'.
          'Tokens are allowed. If left blank, it will use the widget "Input field result text".')
      );      
      break;
      
  }

  return $element;
}


/**
 * Implements hook_field_formatter_settings_summary().
 */
function gst_entityref_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $summary = array();
  switch ($display['type']) {
    case 'gst_entityref_label':
      $context = array('field' => $field, 'form' => Null, 'form_state' => Null);
      drupal_alter('gst_entityref_instance', $instance, $context);      
      $summary[] = $settings['link'] ? t('Link to the referenced entity (GST)') : t('No link');
      $summary[] = $settings['template'] ? $settings['template'] : 
        'Default: ' . $instance['widget']['settings']['inputResultText'];
      break;
  }

  return implode('<br />', $summary);
}


/**
 * Implements hook_field_formatter_prepare_view().
 */
function gst_entityref_field_formatter_prepare_view($entity_type, $entities, $field, $instances, $langcode, &$items, $displays) {
  $target_ids = array();
  //ADFTODO: I think I can remove the node_load_multiple for node_reference becuase the $entities has the 'node' for each
  //  entity in the 'node' array element - I could loop thru and just assign them to the $items array
  //  One thing that IS done here is it "removes" (unsets) any entries that don't have a NODE, not sure if
  //  that is something that is a problem or not.
  $field_type = $field['type'];
  switch ($field_type) {
    case 'entityreference':
      $target_id_name = 'target_id';
      break;
    case 'node_reference':
      $target_id_name = 'nid';
      break;
  }
  //ADFHI: Fix this to handle node_reference - it dies since NR's don't have target_id's
  // Collect every possible entity attached to any of the entities.
  foreach ($entities as $id => $entity) {
    foreach ($items[$id] as $delta => $item) {
      $target_ids[] = $item[$target_id_name];
    }
  }

  if ($target_ids) {
    switch ($field_type) {
      case 'entityreference':        
        $target_entities = entity_load($field['settings']['target_type'], $target_ids);
        break;
      case 'node_reference':
        $target_entities = node_load_multiple($target_ids);        
        break;
    }        

    // Iterate through the fieldable entities again to attach the loaded data.
    foreach ($entities as $id => $entity) {
      $rekey = FALSE;
      foreach ($items[$id] as $delta => $item) {
        // Check whether the referenced entity could be loaded.
        if (isset($target_entities[$item[$target_id_name]])) {
          // Replace the instance value with the term data.
          $items[$id][$delta]['entity'] = $target_entities[$item[$target_id_name]];
        }
        // Otherwise, unset the instance value, since the entity does not exist.
        else {
          unset($items[$id][$delta]);
          $rekey = TRUE;
        }
      }

      if ($rekey) {
        // Rekey the items array.
        $items[$id] = array_values($items[$id]);
      }
    }
  }
}

/**
 * Implements hook_field_formatter_view().
 * Returns a renderable $element array
 */
function gst_entityref_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  $field_type = $field['type'];
  //ADFHI: Add code to the field_collection.module:fc_entity_info() that sets a new "label callback"
  // I should add the ability to set on ANY Field Collection a setting for the "label" that uses "tokens"
  // I don't need to add this code to gst_entityref, I can add it either to the FC module, or add it to
  // another module (gst_field_collections) - I could use fc_entity_info_alter() to add it.
  switch ($display['type']) {
    case 'gst_entityref_label':
      switch ($field_type) {
        case 'entityreference':
          $entity_type = $field['settings']['target_type'];
          $entity_field = 'entity';
          break;
        case 'node_reference':
          $entity_type = 'node';
          $entity_field = 'node';
          break;
      }
      $context = array('field' => $field, 'form' => Null, 'form_state' => Null);
      drupal_alter('gst_entityref_instance', $instance, $context);      

      foreach ($items as $delta => $item) {
        $label = gst_entityref_get_label($item[$entity_field], $instance, $display['settings']['template']);        
        // If the link is to be displayed and the entity has a uri, display a link.
        // Note the assignment ($url = ) here is intended to be an assignment.
        if ($display['settings']['link'] && ($uri = entity_uri($entity_type, $item[$entity_field]))) {
          $element[$delta] = array('#markup' => l($label, $uri['path'], $uri['options']));
        }
        else {
          $element[$delta] = array('#markup' => check_plain($label));
        }
      }
      break;

  }

  return $element;
}


/*
 * LOCAL FUNCTIONS
 * ---------------------------------------------------------------------------
 */

/**
* Returns an unique GST EntityREf id
*/
function _gst_entityref_get_id() {
  static $gst_entityref_id;
  return 'gst-entityref-'. ++$gst_entityref_id;
}

/**
* Return data in JSON format.
*
* This function should be used for JavaScript callback functions returning
* data in JSON format. It sets the header for JavaScript output.
*
* @param $var
*   (optional) If set, the variable will be converted to JSON and output.
*/
function _drupal_jsonp_output($var = NULL, $callback = NULL) {
  if (!isset($callback)) { drupal_json_output($var); return; }
  
  // We are returning JSON, so tell the browser.
  drupal_add_http_header('Content-Type', 'application/json');
  $json = '';
  if (isset($var)) {
    $json = drupal_json_encode($var);
  }
  echo $callback . '(' . $json . ')';
  
}




function _deepCopy($val) {
  return unserialize(serialize($val));
}