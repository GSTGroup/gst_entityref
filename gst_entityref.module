<?php
/**
* @file
* GST Entity Reference
*
*/

/*
 * GLOBAL DEFINES
 */
//define('GST_FIREPHP_ENABLED', 1);

// define('GST_GROUP_SELECT_TABLE_WIDGET', 'gst_og_group_select_table');

define('GST_QUERY_ARG', 'query');
define('GST_CALLBACK_ARG', 'callback');

/**
* Implements hook_help().
*/
function gst_entityref_help($path, $arg) {
  if ($path == 'admin/help#gst_entityref') {
    return t('GST Entity Reference Module.');
  }   
}

/**
* Implementation of hook_init().
*/
function gst_entityref_init() {
  if (GST_FIREPHP_ENABLED) {
    // FirePHP Library : http://www.firephp.org/HQ/Use.htm
    // Docs: http://docs.sourcemint.org/firephp.org/firephp/1/-docs/API/FirePHP
    $firephp_path = libraries_get_path('FirePHPCore');
    $firephp_path = ($firephp_path ? $firephp_path . '/lib/FirePHPCore/' : '');
    include_once $firephp_path . 'FirePHP.class.php';
    //module_load_include('php', 'devel', "FirePHPCore/lib/FirePHPCore/FirePHP.class");
    //require_once('FirePHPCore/FirePHP.class.php');
    global $firephp;
    $firephp = FirePHP::getInstance(true);
    $options = array('maxObjectDepth' => 7,
                     'maxArrayDepth' => 7,
                     'maxDepth' => 10,
                     'useNativeJsonEncode' => true,
                     'includeLineNumbers' => true);
    $firephp->setOptions($options);  // or FB::setOptions($options);
    //$firephp->setEnabled(false);  // To turn off ALL FirePHP Console Messages
  
    //$mail_system = variable_get('mail_system');
    //dpm($mail_system);
    //dfb($mail_system, "mail_system");
  }
}


/**
 * Implements hook_menu().
 */
function gst_entityref_menu() {
  $items = array();

  $items['gst_entityref/search_jsonp/%/%/%/%/%/%'] = array(
    'title' => 'GST Entity Reference Autocomplete',
    'page callback' => 'gst_entityref_autocomplete_callback',
    'page arguments' => array(2, 3, 4, 5, 6, 7),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  
  $items['gst_entityref/search_jsonp/%/%/%/%/%'] = array(
      'title' => 'GST Entity Reference Autocomplete',
      'page callback' => 'gst_entityref_autocomplete_callback',
      'page arguments' => array(2, 3, 4, 5, 6),
      'access callback' => TRUE,
      'type' => MENU_CALLBACK,
  );

  $items['gst_entityref/search_jsonp/%/%/%/%'] = array(
        'title' => 'GST Entity Reference Autocomplete',
        'page callback' => 'gst_entityref_autocomplete_callback',
        'page arguments' => array(2, 3, 4, 5),
        'access callback' => TRUE,
        'type' => MENU_CALLBACK,
  );
  
  return $items;
}

/**
* Implements hook_theme().
*/
function gst_entityref_theme() {
   return array(
     'gst_entityref' => array(
     	//'variables' => array('element' => NULL),
   		'render element' => 'element',
     ),
     'gst_entityref_result' => array(
       'variables' => array('result' => NULL, 'instance' => NULL),       
     ),     
   );
}

/**
* Theme an individual GST Entity Ref Widget
*/
function theme_gst_entityref($variables) {
  global $base_root, $base_path;
  $element = $variables['element'];
  $attributes = &$variables['element']['#attributes'];
  $gst_entityref_options = $element['#gst_entityref_options'];
    
  // Set unique id
  if (!isset($attributes['id'])) {
    $attributes['id'] = _gst_entityref_get_id();
  }
  $source = $base_root . $base_path . 'gst_entityref/search_jsonp' . 
  	'/' . $gst_entityref_options['widget_type'] .                                      
  	'/' . $gst_entityref_options['field_name'] . 
  	'/' . $gst_entityref_options['entity_type'] . 
  	'/' . $gst_entityref_options['bundle_name'] . 
    //'/{query}/{callback}';
  	'?' . GST_QUERY_ARG . '={query}';
  if ($gst_entityref_options['jsonp']) {
    $source .= '&' . GST_CALLBACK_ARG . '={callback}';
  }
    
  // Fill GST EntityRef Options / Settings  
  $gst_entityref_options += array(
    'id' => $attributes['id'],
    'input_id' => $element['gst_entityref_text']['#id'],
    'source' => $source,
    'alwaysShowList' => TRUE,      // For Testing - set to FALSE for Production
  );
  
  // Add gst_entityref.js file to include Behaviors
  $js_path = drupal_get_path('module', 'gst_entityref') . '/gst_entityref.js';
  drupal_add_js($js_path);
  
  // Set Drupal.Settings DOM Object
  drupal_add_js(array('gst_entityref' => array('#'. $attributes['id'] => $gst_entityref_options)), 'setting');
  
  // Load YUI Base Javascript (all other files will be lazy-loaded with YUI.use() )
  //drupal_add_js('http://yui.yahooapis.com/3.4.1/build/yui/yui-min.js', 'external');
  drupal_add_js('http://yui.yahooapis.com/3.4.1/build/yui/yui.js', 'external');
  
  // Begin Building Output
  $output = '<div' . drupal_attributes($attributes) . ">\n";
  $output .= 'GST Entity Ref Widget';
  $output .= drupal_render($element['gst_entityref_text']);
  $output .= '</div>';
  
  return $output;
}

function theme_gst_entityref_result($vars) {
  global $base_root, $base_path;
  $result = $vars['result'];
  $instance = $vars['instance'];
  $output = '';
  $format = $instance['widget']['settings']['resultFormatterCustom'];
  // Format $values so it is of the format {key} = value (instead of key = value)
  $tokens = array(); 
  $values = array();
  foreach($result as $k => $v) {
    $fkey = '{'.$k.'}';
    $tokens[] = $fkey;
    $values[] = $v;
  }
  $output = str_replace($tokens, $values, $format);
  
  return $output;  
}

/**
 * 
 * Implements hook_tokens_alter()
 * @param array $replacements
 * @param array $context
 */
function gst_entityref_token_info_alter(array &$data) {
  
  $data['tokens']['field_collection_item']['host-entity'] = array(
    'name' => 'Host Entity',
    'type' => 'node',
    'entity-token' => TRUE,
    'description' => t('The hosting Entity of the field_collection_item'),
  );
  $data['tokens']['field_collection_item']['host-entity-id'] = array(
      'name' => 'Host Entity ID',
      'type' => 'integer',
      'entity-token' => TRUE,
      'description' => t('The hosting Entity ID of the field_collection_item'),
  );
  $data['tokens']['field_collection_item']['host-entity-type'] = array(
      'name' => 'Host Entity Type',
      'type' => 'string',
      'entity-token' => TRUE,
      'description' => t('The hosting Entity Type of the field_collection_item'),
  );    
}


function gst_entityref_tokens($type, $tokens, array $data = array(), array $options = array()) {
  return;  
  if ($type == 'entity' && $data['entity_type'] == 'field_collection_item' && !empty($data['entity'])) {
    // ADFDONE: Add the ->host_entity properties here
    // I do this in the hook_entity_load() below. Much easier.
    $entity = $data['entity'];    
  }
}

function gst_entityref_entity_load(array $entities, $type) {
  if ($type == 'field_collection_item' && isset($entities)) {
    foreach ($entities as $entity) {
      $entity->host_entity = $entity->hostEntity();
      $entity->host_entity_id = $entity->hostEntityId();
      $entity->host_entity_type = $entity->hostEntityType();
    }
  }
}
/*
 * WIDGET
 */


/**
* Implements hook_field_widget_info().
*/
function gst_entityref_field_widget_info() {
  $widgets['gst_entityref_autocomplete'] = array(
    'label' => t('GST Autocomplete'),
    'description' => t('An enhanced multi-column autocomplete text field.'),
    'field types' => array('entityreference'),
    'settings' => array(
      'match_operator' => 'CONTAINS',
      'size' => 60,
      // We don't have a default here, because it's not the same between
      // the two widgets, and the Field API doesn't update default
      // settings when the widget changes.
  		'path' => '',
  		'use_jsonp' => TRUE,
  		'resultFormatterType' => 'TABLE',
  		'maxResults' => 20,
  		'minQueryLength' => 2,
  		'subFilter' => TRUE,
  		'subFilterDelimeter' => ',',
  		'inputResultText' => '',
    ),
  );

  return $widgets;
}


/**
 * Implements hook_field_widget_settings_form().
 */
function gst_entityref_field_widget_settings_form($field, $instance) {
  $widget = $instance['widget'];
  $settings = $widget['settings'] + field_info_widget_settings($widget['type']);

  $form = array();

  if ($widget['type'] == 'gst_entityref_autocomplete') {
    $form['use_jsonp'] = array(
    	'#type' => 'checkbox',
      '#title' => t('Use JSONP Request/Callback'),
      '#default_value' => isset($settings['use_jsonp']) ? 
        $settings['use_jsonp'] : TRUE,
     	'#access' => TRUE,
    );

    $form['resultFormatterType'] = array(
      '#type' => 'select',
      '#title' => t('Result formatter type'),
      '#default_value' => isset($settings['resultFormatterType']) ? $settings['resultFormatterType'] : 'TABLE',
      '#options' => array(
        'TABLE' => t('Table'),
        'CUSTOM' => t('Custom'),
        ),
    	'#required' => TRUE,
      '#description' => t('Select the method used to display results.'),
    );
    
    $form['resultFormatterCustom'] = array(
      '#type' => 'textarea',
      '#title' => t('Custom result formatter template'),
      '#default_value' => isset($settings['resultFormatterCustom']) ? $settings['resultFormatterCustom'] : '',
    	'#required' => FALSE,
    	'#rows' => 7,
      '#description' => t('Enter the custom result formatter template to use.'),
      '#states' => array(
        'visible' => array(  // action to take.
        ':input[name="instance[widget][settings][resultFormatterType]"]' => array('value' => 'CUSTOM'),
        ),
      ),      
    );
    
    $form['maxResults'] = array(
      '#type' => 'textfield',
      '#title' => t('Maximun number of results'),
      '#default_value' => isset($settings['maxResults']) ? $settings['maxResults'] : 20,
      '#element_validate' => array('_element_validate_integer_positive'),
      '#required' => TRUE,
      '#description' => t('Maximum number of results to display. A value of 0 or less will allow an unlimited number of results.'),
    );

    $form['minQueryLength'] = array(
      '#type' => 'textfield',
      '#title' => t('Minimum query length'),
      '#default_value' => isset($settings['minQueryLength']) ? $settings['minQueryLength'] : 2,
      '#element_validate' => array('_element_validate_integer_positive'),
      '#required' => TRUE,
    	'#description' => t('Minimum number of characters that must be entered before a query event will be fired. A value of 0 allows empty queries.'),
    );
    
    $form['match_operator'] = array(
      '#type' => 'select',
      '#title' => t('Autocomplete matching'),
      '#default_value' => isset($settings['match_operator']) ? $settings['match_operator'] : 'CONTAINS',
      '#options' => array(
        'STARTS_WITH' => t('Starts with'),
        'CONTAINS' => t('Contains'),
      ),
      '#description' => t('Select the method used to collect autocomplete suggestions. Note that <em>Contains</em> can cause performance issues on sites with thousands of nodes.'),
    );
    $form['size'] = array(
      '#type' => 'textfield',
      '#title' => t('Size of textfield'),
      '#default_value' => isset($settings['size']) ? $settings['size'] : 60,
      '#element_validate' => array('_element_validate_integer_positive'),
      '#required' => TRUE,
    );
    
    $form['inputResultText'] = array(
    	'#type' => 'textfield',
      '#title' => t('Input field result text'),
      '#default_value' => isset($settings['inputResultText']) ? $settings['inputResultText'] : '',
      '#description' => t('This is the text that will be put into the input field once a selection is made.<br>Tokens are allowed.'),      
      '#required' => FALSE,
    );
    
    if (module_exists('token')) {
      // Add token module replacements fields
      $form['tokens'] = array(
        '#type' => 'fieldset',
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
        '#title' => t('Placeholder tokens'),
        '#description' => t("The following placeholder tokens can be used in Input Result Text. When used, they will be replaced with the appropriate values."),
      );
      $token_type = array(
        'theme' => 'token_tree',
        'token_types' => array(
          $instance['entity_type'],
          $field['settings']['target_type'],
          ),
        'global_types' => TRUE,
        'click_insert' => TRUE,
        'recursion_limit' => 2,
      );
      $form['tokens']['help'] = array(
        '#type' => 'markup',
        '#markup' => theme('token_tree', $token_type),
      );    
    }    
  }

  // HOOK_gst_entityref_settings_form_alter
  $vars = array(
    'field' => $field,
    'instance' => $instance,
    'settings' => $settings,
  );
  drupal_alter('gst_entityref_settings_form', $form, $vars);
  return $form;
}

/**
* Implements hook_field_widget_info_alter().
*/
function gst_entityref_field_widget_info_alter(&$info) {
  $info['options_select']['field types'][] = 'entityreference';
  $info['options_buttons']['field types'][] = 'entityreference';
}

/**
* Implements hook_field_widget_form().
*/
function gst_entityref_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  // Return the Standard Entity Reference Form for Testing
  //return _entityreference_field_widget_form($form, $form_state, $field, $instance, $langcode, $items, $delta, $element);
  //ADFHI: Add code that takes the values stored in the $settings and set the YUI to be set correct (including maxQueryLength, etc)
  //ADFHI: Fix term matches. Currently, if you type in "paul" that matches a term, so returns 2 entries, but
  //  since the "highlight" match doesn't match an entry, the drop-down does not show up. Need to fix this.
  // Allow any client form to update widget
  $context = array('field' => $field, 'form' => $form, 'form_state' => $form_state);
  drupal_alter('gst_entityref_instance', $instance, $context);
  switch ($instance['widget']['type']) {
    case 'gst_entityref_autocomplete':
      $settings = $instance['widget']['settings'];
      $jsonp = $settings['use_jsonp'];
      $gst_entityref_options = array(
        'widget_type' => 'yui-std',
        'resultFilters' => array('subWordMatch'),
        'field_name' => $field['field_name'],
        'entity_type' => $instance['entity_type'],
        'bundle_name' => $instance['bundle'],
        'jsonp' => $jsonp,
        'maxResults' => $settings['maxResults'],
        'minQueryLength' => $settings['minQueryLength'],
        'resultTextLocator' => 'inputResultText',
        'resultFormatTemplate' => $instance['widget']['settings']['resultFormatterCustom'],
      );
      $element_ref = array(
      	'#type' => 'gst_entityref',
      	'#theme' => 'gst_entityref',
        '#tree' => TRUE,
      	'#title' => 'GST Entity Ref T',
        '#default_value' => 'GST Entity Ref DV',        
        '#attributes'=> array(
          'class' => array('gst-entityref'),
          ),
        '#gst_entityref_options' => $gst_entityref_options,
        '#widget' => $instance['widget'],
      );      
      $element_ref['gst_entityref_text'] = array(
        '#type' => 'textfield',
        '#attributes' => array(
        ),        
      );
      
      break;
  }
  
  
  return $element_ref;
}


/**
 * Implements hook_field_widget_form().
 */
function _entityreference_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $handler = entityreference_get_handler($field);

  if ($instance['widget']['type'] == 'gst_entityref_autocomplete') {

    if ($instance['widget']['type'] == 'gst_entityref_autocomplete') {
      // We let the Field API handles multiple values for us, only take
      // care of the one matching our delta.
      if (isset($items[$delta])) {
        $items = array($items[$delta]);
      }
      else {
        $items = array();
      }
    }

    $entity_ids = array();
    $entity_labels = array();

    // Build an array of entities ID.
    foreach ($items as $item) {
      $entity_ids[] = $item['target_id'];
    }

    // Load those entities and loop through them to extract their labels.
    $entities = entity_load($field['settings']['target_type'], $entity_ids);

    foreach ($entities as $entity_id => $entity) {
      $label = $handler->getLabel($entity);
      $key = "$label ($entity_id)";
      // Labels containing commas or quotes must be wrapped in quotes.
      if (strpos($key, ',') !== FALSE || strpos($key, '"') !== FALSE) {
        $key = '"' . str_replace('"', '""', $key) . '"';
      }
      $entity_labels[] = $key;
    }

    if ($instance['widget']['type'] == 'gst_entityref_autocomplete') {
      $path = !empty($instance['widget']['settings']['path']) ? $instance['widget']['settings']['path'] : 'gst_entityref/autocomplete/single';
      $element += array(
        '#type' => 'textfield',
        '#maxlength' => 1024,
        '#default_value' => implode(', ', $entity_labels),
        '#autocomplete_path' => $path . '/' . $field['field_name'] . '/' . $instance['entity_type'] . '/' . $instance['bundle'],
        '#size' => $instance['widget']['settings']['size'],
        //ADFTODO: Add Validation
        //ADF'#element_validate' => array('_entityreference_autocomplete_validate'),
      );
      return array('target_id' => $element);
    }
    else {
      $path = !empty($instance['widget']['settings']['path']) ? $instance['widget']['settings']['path'] : 'gst_entityref/autocomplete/tags';
      $element += array(
        '#type' => 'textfield',
        '#maxlength' => 1024,
        '#default_value' => implode(', ', $entity_labels),
        '#autocomplete_path' => $path . '/' . $field['field_name'] . '/' . $instance['entity_type'] . '/' . $instance['bundle'],
        '#size' => $instance['widget']['settings']['size'],
        //ADFTODO: Add Validation
        //ADF'#element_validate' => array('_entityreference_autocomplete_tags_validate'),
      );
      return $element;
    }
  }
}

/*
 * Adds a field to be used for searching/display/highlight
 * This function should ONLY be called from teh hook_gst_entityref_settings_form_alter hook
 * 
 * @param $form The form to add the joins to. This is passed in the HOOK
 * @param $data This is an array of data containing the Join to add The array
 *   should be of the form:
 *   array(
 *   	'unique-name' => array(
 *   		'join' => array(),
 *   		''
 *   	),
 *   )
 * @return
 */
function gst_entityref_add_filter_field(array &$form, array $data) {
  if (!isset($form['filter_fields'])) {
    $form['filter_fields'] = array();
  }  
  $form['filter_fields'] += $data;
}

/**
* Menu callback: autocomplete the label of an entity.
* NOTE: We use query= and callback= URL Args *instead* of standard Drupal /%/% args for
* 		query & callback to solve issues with '/' chars. When I used std %/% the '/' chars
* 		while "converted" correctly on the client, created 403 errors on the server, so I changed code.
*/
function gst_entityref_autocomplete_callback($type, $field_name, $entity_type, $bundle_name) {
  $string = $_GET[GST_QUERY_ARG];
  $callback = $_GET[GST_CALLBACK_ARG];
  
  $val = array(
    '0' => "val1 bob/jack $type $field_name $entity_type $bundle_name",
    '1' => "val2 jack/mary $type $field_name $entity_type $bundle_name",
    '2' => "val3 bob/mam $type $field_name $entity_type $bundle_name",
    '3' => "val4 $type $field_name $entity_type $bundle_name",
  );
  
  
  $field = field_info_field($field_name);
  $instance = field_info_instance($entity_type, $field_name, $bundle_name);
  // Allow any client form to update widget
  $context = array('field' => $field, 'form' => Null, 'form_state' => Null);
  drupal_alter('gst_entityref_instance', $instance, $context);  
  
  $matches = array();      // Un-Indexed list of Matches (this is what we MUST return to JSONP)
  $imatches = array();     // Indexed list of Matches (indexed by entity_id)
  if (!$field || !$instance || $field['type'] != 'entityreference' || !field_access('edit', $field, $entity_type)) {
    return MENU_ACCESS_DENIED;
  }

  $handler = entityreference_get_handler($field);

  $tag_last = $string;
  //$entity_labels = $handler->getReferencableEntities($tag_last, $instance['widget']['settings']['match_operator'], 10);
  //$query = _buildEntityFieldQuery($field, $tag_last, $instance['widget']['settings']['match_operator'], 10);
  
  $field['entity_type'] = $entity_type;
  $field['bundle_name'] = $bundle_name;
  $efq = _buildQuery2($field, $tag_last, $instance['widget']['settings']['match_operator'], 20);
  $efq->addMetaData('widget', $instance['widget']);
  //NOTE: The following is "hackish" but is *necessary* because of how the EFQ handles
  // query results. Problem is, the EFQ HURLS any fields that are added, and ONLY returns
  // an "entity" records, so it doesn't matter that I just went out to the DB and grabbed
  // a set of 8 tables, all I get back is the ENTITY. While I can understand this, there
  // are *times* when I want what I asked for (ie. the set of field results).
  // Now, I could junk the EFQ entirely, and use a db_select() (which might be better),
  // but I wrote it this way for now. THAT is the reason I run the $efq->execute() and then later
  // run the $select_query->execute().
  $results = $efq->execute();
  $select_query = $efq->metaData['select_query'];
  $full_results = $select_query->execute();
  //ADFHI: Complete the code to create the $matches
  //ADFHI: Include the code that sets the inputText (set this to the arg in the $instance)
  // Build the $matches result set to send to the client 
  // (NOTE: This result set COULD have MULTIPLE entries for each FC item due to the taxonomy matches - so check for that.
  $mk_prefix = 'm_';
  $sk_prefix = 's_';
  if (!empty($full_results)) {
    foreach($full_results as $record) {
      $rec = (array)$record; // Convert stdClass to Array (so we can merge)
      $entity_id = $rec['entity_id'];
      if (isset($imatches[$entity_id])) {
        $imatches[$entity_id]['#multiple'] = isset($imatches[$entity_id]['#multiple']) ? $imatches[$entity_id]['#multiple']+1 : 2;
        // Create "multiple" entries for each entry
        foreach($rec as $k => $v) {
          if ($k[0] === '#' || !isset($v)) { continue; }
          if (is_array($imatches[$entity_id][$k])) {
            // This Key is a Multi-Value - add NEW value (if it is the same as an existing, it will do NOTHING, since array is associative)            
            $imatches[$entity_id][$k][$v] = $v;
          } elseif (isset($rec[$k]) && $imatches[$entity_id][$k] != $rec[$k]) {
            // New Value Exists (not NULL), not the same as Existing - need to convert to an array to store both.
            $existing = $imatches[$entity_id][$k];
            $imatches[$entity_id][$k] = array(
              $existing => $existing,
              $v => $v,
            );
          } else {
            // Not an array, but New value either doesn't exist, or is same as existing - do nothing            
          }
        }
      } else {
        $imatches[$entity_id] = $rec;        
      }
    }
    // Load the Entity objects for Token Processing
    $target_entity_type = $field['settings']['target_type'];
    $entities = entity_load($target_entity_type, array_keys($imatches));
    // Now fix all the multi-values (convert to delimited strings)
    $inputResultTextTemplate = $instance['widget']['settings']['inputResultText'];
    foreach ($imatches as $entity_id => $rec) {
      if (isset($rec['#multiple']) && $rec['#multiple']) {
        // Handle matches that had multiple matches with the same item_collection entity_id
        // (this likely means the FC has multiple "term" matches)
        foreach ($rec as $k => $v) {
          if (is_array($v)) {
            $mk = $mk_prefix . $k;
            $sk = $sk_prefix . $k;
            $imatches[$entity_id][$sk] = reset($v);          // Store the FIRST value in the s_{key} field
            $imatches[$entity_id][$k] = implode(',', $v);    // Store the delimited value in the {key} field
            // Try and see if the $match passed matches any of these values, if so, set that one, if not, set the FIRST value
            //ADFHI: Add code to do the above (I should do this AFTER I move to array-based $match strings)
            //$imatches[$entity_id][$k] = reset($v); // Store the FIRST value in the non-multiple
          }        
        }
      }
      // Add the inputText value to the $match entry
      //ADFHI: Figure out why I need to turn sanitize off. If I turn it on, it passes & chars to browser for apostrophes      
      $inputResultText = token_replace($inputResultTextTemplate, 
        array('field_collection_item' => $entities[$entity_id]), array('sanitize' => FALSE));
      $imatches[$entity_id]['inputResultText'] = $inputResultText . " (" . $entity_id . ")";
      
      $vars = array(
        'result' => $imatches[$entity_id],
        'instance' => $instance,      
      );
      $imatches[$entity_id]['formattedResult'] = theme('gst_entityref_result', $vars);
      
      
      // Now create the un-indexed version to send to the CLIENT in JSON
      $matches[] = $imatches[$entity_id];      
    }
  }
  
  
  
  _drupal_jsonp_output($matches, $callback);
  return;

  
  // When I get to "multiple tags" the following code will be useful to review
  if ($type == 'tags') {
    // The user enters a comma-separated list of tags. We only autocomplete the last tag.
    $tags_typed = drupal_explode_tags($string);
    $tag_last = drupal_strtolower(array_pop($tags_typed));
    if (!empty($tag_last)) {
      $prefix = count($tags_typed) ? implode(', ', $tags_typed) . ', ' : '';
    }
  }
  else {
    // The user enters a single tag.
    $prefix = '';
    $tag_last = $string;
  }

  if (!empty($tag_last)) {
    // Get an array of matching entities.
    $entity_labels = $handler->getReferencableEntities($tag_last, $instance['widget']['settings']['match_operator'], 10);

    // Loop through the products and convert them into autocomplete output.
    foreach ($entity_labels as $entity_id => $label) {
      $key = "$label ($entity_id)";
      // Names containing commas or quotes must be wrapped in quotes.
      if (strpos($key, ',') !== FALSE || strpos($key, '"') !== FALSE) {
        $key = '"' . str_replace('"', '""', $key) . '"';
      }
      $matches[$prefix . $key] = '<div class="reference-autocomplete">' . $label . '</div>';
    }
  }

}


function gst_entityref_query_gst_entityref_alter(QueryAlterableInterface $query) {
  if (!$query->alterTags['gst_entityref']) {
    return;
  }
  $widget = $query->getMetaData('widget');
  $settings = $query->getMetaData('settings');
  $match = $settings['match'];
  $query_extra = $widget['settings']['query_extra'];
  
  // Make Adjustments to Query
  //ADFTODO: Add code to handle alias conflicts in joins
  if (isset($query_extra['joins'])) {
    foreach ($query_extra['joins'] as $j) {
      $method = $j['method'];
      $talias = $query->$method($j['table'], $j['alias'], $j['condition'], $j['args']);
    }
  }
  //ADFTODO: Add code to handle alias conflicts in fields
  //ADFHI: Add code to handle "sort order" - I should probably add this to the fields as an "option" for each field.
  $orders = array();
  if (isset($query_extra['fields'])) {
    foreach ($query_extra['fields'] as $f) {      
      $falias = $query->addField($f['table_alias'], $f['field_name'], $f['field_alias']);
      if (isset($f['sort'])) {
        $sort_dir = isset($f['sort_dir']) ? $f['sort_dir'] : 'ASC';
        //ADFTODO: Add code to handle two fields with 'sort' => SAME value.
        $orders[$f['sort']] = array(
        	'name' => $f['field_alias'],
        	'dir' => $sort_dir
          );
      }
    }
  }
  ksort($orders);    // Sort by KEY
  foreach ($orders as $i => $order) {
    $query->orderBy($order['name'], $order['dir']);      
  }
  
  //ADFTODO: Add code to handle alias conflicts created by joins/fields to fix $conditions
  //ADFDONE: Add $conditions processing. Should be easy since all it does is copy it in.
  //ADFDONE: When adding conditions, have to replace %match with match value, and have to fix operator 'default' values.
  if (isset($query_extra['conditions'])) {
    $conditions = $query_extra['conditions'];    
    $match_operator = $widget['settings']['match_operator'];
    $c_conditions = &$conditions->conditions();
    _process_conditions($c_conditions, $match, $match_operator);
    $q_conditions = &$query->conditions();    
    $q_conditions = array_merge($q_conditions, $c_conditions);
  }
  // Save the db_select SelectQuery object - we will need it LATER
  // - this is necessary because the EFQ returns a "partial" entity; it strips out ALL
  // - the extra "fields" that I add, and I WANT those for display.
  $efq = &$query->getMetaData('entity_field_query');
  $efq->metaData['select_query'] = $query;
  
  // Remove the Alter Tag so I don't end up here AGAIN
  $query->alterTags['gst_entityref'] = 0;
  $qs = $query->__toString();
}

//ADFHI: Add processing for subFilter here.
// I think if I just loop thru ALL the $match entries (if $match has a delimter)
// and do the following I can make it work easily.
// 1) add all $conditions for $match[0] (the first "query").
// 2) loop thru $conditions for every other $match and if $value = %match, then
//    add that condition *again* but with the 2nd (and following) $match[1] value.
//    if $value != %match, REMOVE that condition (or don't add it).
//   NOTE: These 2nd and following $condition loops wil need to be added with db_and()

function _process_conditions(&$conditions, $match, $match_operator) {
  foreach($conditions as $key => $condition) {    
    if ($key[0] === '#' || empty($condition['operator'])) {
      // #conjunction OR Literal Condition - Skip
    } else {
      if ($condition['field'] instanceof QueryConditionInterface) {
        // Condition is a Structured Condition Object - recursively process
        $cref = &$condition['field']->conditions();
        _process_conditions($cref, $match, $match_operator);
      } else {
        // Process Condition
        $value = isset($condition['value']) ? $condition['value'] : '';
        $op = isset($condition['operator']) ? $condition['operator'] : '';

        switch ($op) {
          case '%default':
          case 'default':
            $m_operator = $match_operator;
            break;
          default:
            $m_operator = $op;
          break;
        }
        
        switch ($value) {
          case '%match':
            $c_value = $match;
            break;
        }
        switch ($m_operator) {
          case 'CONTAINS':
            $c_operator = "LIKE";
            $c_value = '%'.$c_value.'%';
            break;
          case 'STARTS_WITH':
            $c_operator = "LIKE";
            $c_value = $c_value.'%';
            break;
        }        
        $conditions[$key]['value'] = $c_value;
        $conditions[$key]['operator'] = $c_operator;
      }
    }
  }
}

function gst_entityref_gst_entityref_preformat_alter(&$vars) {
  $v = $vars;
//   $vars['modify'] = 'modify';
//   $vars['results']['mod'] = 'modify';
//   $vars['entities'][1]->modify = 'modify';
}

/*
 * LOCAL FUNCTIONS
 * ---------------------------------------------------------------------------
 */

/**
* Returns an unique GST EntityREf id
*/
function _gst_entityref_get_id() {
  static $gst_entityref_id;
  return 'gst-entityref-'. ++$gst_entityref_id;
}

/**
* Return data in JSON format.
*
* This function should be used for JavaScript callback functions returning
* data in JSON format. It sets the header for JavaScript output.
*
* @param $var
*   (optional) If set, the variable will be converted to JSON and output.
*/
function _drupal_jsonp_output($var = NULL, $callback = NULL) {
  if (!isset($callback)) { drupal_json_output($var); return; }
  
  // We are returning JSON, so tell the browser.
  drupal_add_http_header('Content-Type', 'application/json');
  $json = '';
  if (isset($var)) {
    $json = drupal_json_encode($var);
  }
  echo $callback . '(' . $json . ')';
  
}

function _buildEntityFieldQuery($field, $match = NULL, $match_operator = 'CONTAINS', $limit = 0) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', $field['settings']['target_type']);
  if ($field['settings']['handler_settings']['target_bundles']) {
    $query->entityCondition('bundle', $field['settings']['handler_settings']['target_bundles'], 'IN');
  }
  if (isset($match)) {
    $entity_info = entity_get_info($field['settings']['target_type']);
    if (isset($entity_info['entity keys']['label'])) {
      $query->propertyCondition($entity_info['entity keys']['label'], $match, $match_operator);
    }
    //$query->propertyCondition('title', $match, $match_operator);
  }
  
  // Add a generic entity access tag to the query.
  $query->addTag($field['settings']['target_type'] . '_access');
  $query->addTag('entityreference');
  $query->addMetaData('field', $field);
  
  // Add the sort option.
  if (!empty($field['settings']['handler_settings']['sort'])) {
    $sort_settings = $field['settings']['handler_settings']['sort'];
    if ($sort_settings['type'] == 'property') {
      $query->propertyOrderBy($sort_settings['property'], $sort_settings['direction']);
    }
    elseif ($sort_settings['type'] == 'field') {
      list($field, $column) = explode(':', $sort_settings['field'], 2);
      $query->fieldOrderBy($field, $column, $sort_settings['direction']);
    }
  }  
  if ($limit > 0) {
    $query->range(0, $limit);
  }
  return $query;  
  
}

function _buildQuery2($field, $match = NULL, $match_operator, $limit = 0) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', $field['settings']['target_type']);
  if ($field['settings']['handler_settings']['target_bundles']) {
    $query->entityCondition('bundle', $field['settings']['handler_settings']['target_bundles'], 'IN');
  }
  if (isset($match)) {
    $entity_info = entity_get_info($field['settings']['target_type']);
    if (isset($entity_info['entity keys']['label'])) {
      $query->propertyCondition($entity_info['entity keys']['label'], $match, $match_operator);
    }
    //$query->propertyCondition('title', $match, $match_operator);
  }
  
  // Add a generic entity access tag to the query.
  $query->addTag($field['settings']['target_type'] . '_access');
  //$query->addTag('entityreference'); // Hook = gst_entityref_query_entityreference_alter()
  
  
  // --- NOTE ---
  // I can't add the "joins" here and then expect them to be processed
  // The problem is quite simple, if I add the "joins" here (first) then the first
  // time they will EVER be processed will be upon the first AutoComplete AJAX request.
  // By that time, the YUI code has ALREADY been sent to the client.
  // I will need to create the "joins" early (before the Widget is sent to the client)
  // and then later take that set of "joins" and perform the "join" operation.
  // Probably I should create an API that allows the user to "specify" the 
  // Joins on "build" and then later, take that set of "joins" and then add them
  // in the gst_entityref_query_gwst_entityref_alter() routine (adding them to the db_select() )
  // --- NOTE ---
  
  $query->addTag('gst_entityref'); // Hook = gst_entityref_query_gst_entityref_alter()
  $query->addMetaData('field', $field);
  
  
  $target_bundles = $field['settings']['handler_settings']['target_bundles'];
  $tb = array();
  foreach(array_keys($target_bundles) as $bundle_name) {
    $f_field = field_info_field($bundle_name);
    $tb[$bundle_name]['field'] = $f_field;
    foreach($f_field['bundles'] as $entity_type => $entities) {
      foreach($entities as $entity_name) {
        $f_instance = field_info_instance($entity_type, $f_field['field_name'], $entity_name);
        $tb[$bundle_name][$entity_type . "." . $entity_name] = $f_instance;
      }
    }
  }
  
  //---------------------\\
  
  // I have decided that it is too ambitious to try and create a "dynamic" system
  // that lets me define the "joins" using a single string. I would have to have
  // extensive schema knowledge and understanding that I don't have.
  // A better system would be to have a "routine" that uses a "tag" to fill the
  // EntityRef with the joins. If I strongly specify how the joins are created
  // later I can add a UI to that interface. At some point then beyond that
  // I can add the "token" like linkage. So the dev of this widget wil be 3 
  // phased:
  // 1) Code the joins in PHP (but tied to a specific field)
  // 2) Add a UI that can add that data
  // 3) Add the ability to create that information with the Token system.
  
  //---------------------\\


  //ADFHI: Clean up "settings" - I have them being stored in the $widget and the $query - need to clean it up.
  $settings = array(
    'match' => $match,
    'match_operator' => $match_operator,    
  );
  $query->addMetaData('settings', $settings);
  
  if ($limit > 0) {
    $query->range(0, $limit);
  }
  return $query;  
}


function _buildQuery($field, $match = NULL, $match_operator, $limit = 0) {
  // Based upon what I can see in the SQL, I need to do the following to *just* get the FC/ERefs that the user wants:
  // 1) Make a list that contains the following for each target_bundle
  //    $entity_type (this is the 1st level, usually 'node')
  //    $entity_name (this is the 2nd level, usually a content type, like 'gstcourse'
  // 2) This 'target_bundle' list has to be added as Conditions to the Select Query
  //    For each entry in target_bundles:
  //      condition('entity_type', $entity_type)
  //      condition('bundle', $entity_name) <- in the FC Table, the "bundle" column has the $entity_name
  //    These are all conditions against table: "field_data_" . $f_field['field_name']
  // 3) I need to ensure I *include* that table - in fact, that table is to become the BASE table for
  //    the entire query (it is the center, all other Joins go out from it)
  //
  $target_bundles = $field['settings']['handler_settings']['target_bundles'];
  $tb = array();
  foreach(array_keys($target_bundles) as $bundle_name) {
    $f_field = field_info_field($bundle_name);
    $tb[$bundle_name]['field'] = $f_field;
    foreach($f_field['bundles'] as $entity_type => $entities) {
      foreach($entities as $entity_name) {
        $f_instance = field_info_instance($entity_type, $f_field['field_name'], $entity_name);
        $tb[$bundle_name][$entity_type . "." . $entity_name] = $f_instance;        
      }
    }
  }
  
  $fc18 = field_collection_item_load(18);
  
  $query = db_select('field_data_field_c_lessons', 'c_lessons')
    ->fields('c_lessons', array('field_c_lessons_value'))
    ->fields('nlesson', array('nid', 'title'))
    ->fields('ccl_label', array('field_ccl_label_value'))
    ->fields('ncourse', array('nid', 'title'))
    ->fields('tdata', array('name', 'description'));
  $a1 = $query->innerJoin('node', 'ncourse', 'ncourse.nid = c_lessons.entity_id');
  $a2 = $query->join('field_data_field_ccl_label', 'ccl_label', 'c_lessons.field_c_lessons_value = ccl_label.entity_id');
  $a3 = $query->join('field_data_field_ccl_lesson', 'ccl_lesson', 'c_lessons.field_c_lessons_value = ccl_lesson.entity_id');
  $a4 = $query->innerJoin('node', 'nlesson', 'nlesson.nid = ccl_lesson.field_ccl_lesson_nid');
  $a5 = $query->join('taxonomy_index', 'tindex', 'tindex.nid = nlesson.nid');
  $a6 = $query->innerJoin('taxonomy_term_data', 'tdata', 'tdata.tid = tindex.tid');  
  $query
    ->condition('nlesson.type', 'gstlesson')
    ->condition(db_or()
      ->condition('nlesson.title', '%' . $match . '%', 'LIKE')
      ->condition('ncourse.title', '%' . $match . '%', 'LIKE')
      ->condition('tdata.name', '%' . $match . '%', 'LIKE')
      ->condition('tdata.description', '%' . $match . '%', 'LIKE')
      );
  if ($limit > 0) {
    $query->range(0, $limit);
  }
  $qs = $query->__toString();
  
  return $query;
}